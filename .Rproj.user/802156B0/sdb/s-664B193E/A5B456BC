{
    "collab_server" : "",
    "contents" : "#!/usr/bin/env Rscript\n\n# cross-validate optimal cutoff of SIFT\nlibrary(ROCR)\nlibrary(argparser)\n\n# create an arg.parser object for parsing command line arguments\nargs.parser <- arg_parser(description = \"This script takes a list of (prediction, label) pairs and does a \n                          k-fold cross validation of the procedure for choosing optimimal cut-off based on MCC\",\n                          name = \"cv_cutoff\")\nargs.parser <- add_argument(parser = args.parser, arg = \"-i\", help = \"input file\")\nargs.parser <- add_argument(parser = args.parser, arg = \"-k\", help = \"number of folds\", default = 3)\nargs.parser <- add_argument(parser = args.parser, arg = \"-r\", help = \"number of repeats\", default = 1)\n\n# parse command line arguments\nargv <- parse_args(parser = args.parser)\n\n# load the input file\ndata <- read.csv(file = argv$i, header = FALSE, sep = \",\")\ncolnames(data) <- c(\"prediction\", \"label\")\n\n# split the dataset into negatives and positives, drop levels that do not occur\nsubsets <- split(x = data, f = as.factor(data$label), drop = TRUE)\nnegatives <- subsets[[1]]\npositives <- subsets[[2]]\n\n# do the cross validation\nvec <- numeric(length = argv$r * argv$k)\nmat <- matrix(data = vec, nrow = argv$r, ncol = argv$k, byrow = TRUE)\ntprs <- tnrs <- accs <- mccs <- aucs <- mat\n\nfor(i in 1:argv$r) {\n  # shuffle each subsets\n  negatives <- negatives[sample(x = 1:nrow(negatives)),]\n  positives <- positives[sample(x = 1:nrow(positives)),]\n  \n  # create folds\n  neg.folds <- cut(x = 1:nrow(negatives), breaks = argv$k, labels = FALSE)\n  pos.folds <- cut(x = 1:nrow(positives), breaks = argv$k, labels = FALSE)\n  for(j in 1:argv$k) {\n    # create test set and training set\n    test <- rbind(negatives[neg.folds == j,], positives[pos.folds == j,])\n    train <- rbind(negatives[neg.folds != j,], positives[pos.folds != j,])\n    \n    # find the optimimal cut-off value from the training set\n    rocr <- prediction(predictions = train$prediction, labels = train$label)\n    rocr.perf <- performance(prediction.obj = rocr, measure = \"mat\", x.measure = \"cutoff\")\n    optimal.cutoff.index <- which.max(unlist(rocr.perf@y.values))\n    optimal.cutoff <- unlist(rocr.perf@x.values)[optimal.cutoff.index]\n    \n    # compute the Matthews correlation coefficient on the test set\n    test$prediction <- ifelse(test$prediction <= optimal.cutoff, 0, 1)\n    rocr.test <- prediction(predictions = test$prediction, labels = test$label)\n    rocr.test.perf <- performance(prediction.obj = rocr.test, measure = \"mat\", x.measure = \"cutoff\")\n    \n    # mat.unlisted is a vector with all but one elements is NaN\n    mcc.unlisted <- unlist(rocr.test.perf@y.values)\n    mcc <- mcc.unlisted[2]\n    ifelse(length(mcc) == 0 || mcc < 0, mccs[i, j] <- NA, mccs[i, j] <- mcc)\n    \n    # add tpr\n    tpr.unlisted <- unlist(performance(prediction.obj = rocr.test, measure = \"tpr\")@y.values)\n    tprs[i, j] <- tpr.unlisted[2]\n    \n    # add tnr\n    tnr.unlisted <- unlist(performance(prediction.obj = rocr.test, measure = \"tnr\")@y.values)\n    tnrs[i, j] <- tnr.unlisted[2]\n    \n    # add accuracy\n    acc.unlisted <- unlist(performance(prediction.obj = rocr.test, measure = \"acc\")@y.values)\n    accs[i, j] <- acc.unlisted[2]\n    \n    # compute  auc and store it in the numeric vector aucs\n    auc <- unlist(performance(prediction.obj = rocr.test, measure = \"auc\")@y.values)\n    aucs[i, j] <- auc\n  }\n}\n\n# print the matrix\ntprs <- cbind(tprs, apply(tprs, MARGIN = 1, FUN = mean))\ntnrs <- cbind(tnrs, apply(tnrs, MARGIN = 1, FUN = mean))\naccs <- cbind(accs, apply(accs, MARGIN = 1, FUN = mean))\nmccs <- cbind(mccs, apply(mccs, MARGIN = 1, FUN = mean))\naucs <- cbind(aucs, apply(aucs, MARGIN = 1, FUN = mean))\nprint(mean(tprs[, 4], na.rm = TRUE))\nprint(mean(tnrs[, 4], na.rm = TRUE))\nprint(mean(accs[, 4], na.rm = TRUE))\nprint(mean(mccs[, 4], na.rm = TRUE))\nprint(mean(aucs[, 4], na.rm = TRUE))\n",
    "created" : 1494603417506.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2822697265",
    "id" : "A5B456BC",
    "lastKnownWriteTime" : 1496083089,
    "last_content_update" : 1496083090004,
    "path" : "~/workspace/rscripts/kcnq1_modeling/cv_cutoff.R",
    "project_path" : "cv_cutoff.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}